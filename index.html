<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Short introduction of Landset OLI</title>
    <meta charset="utf-8" />
    <meta name="author" content="Lu Zhao" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="Extra_css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Short introduction of Landset OLI
]
.subtitle[
## Week2 Presentation
]
.author[
### Lu Zhao
]
.institute[
### CASA
]
.date[
### 2023/01/25 (updated: 2023-02-14)
]

---



class: inverse, center, middle
# Outline
## Summary
## Application
## Reflection
---
class: left, left
# Summary

.small[* The Landsat 8 satellite carries the Operational Land Imager (OLI) sensor, which is responsible for measurements in the visible, near-infrared and short-wave infrared components. Its images are available as panchromatic images with a spatial resolution of 15 meters and multi-spectral images of 30 meters. In addition, its observable area is extensive.]

--

* The OLI sensor is a push-broom image acquisition sensor, which has a long array of photosensitive detectors.

--
.pull-left[

&lt;img src="literature/oli_design.jpg" width="60%" style="display: block; margin: auto;" /&gt;
&lt;font size = 1&gt; Fig.1 Drawing of the Operational Land Imager (OLI)
Source: [**OLI DESIGN**](https://landsat.gsfc.nasa.gov/article/oli-design/)
]

---
class: inverse, left, left
## Application

1.Application in comparing the changes in land use and land cover
.pull-left[
&lt;img src="literature/Application1_1.png" width="50%" style="display: block; margin: auto;" /&gt;
&lt;font size = 1&gt; Fig.2 False color image in Blantyre City collected by OLI sensor 
]

.pull-right[
&lt;img src="literature/Application1_2.png" width="80%" style="display: block; margin: auto;" /&gt;
&lt;font size = 1&gt; Fig.3 Land use land cover classes in Blantyre City in 2018 
]

---
class: inverse, left, left
## Application

2.Application in urban land expansion analysis

&lt;img src="literature/Application2.png" width="70%" style="display: block; margin: auto;" /&gt;
&lt;font size = 1&gt; Fig.4 Urban expansion in Pearl River Delta

---
class: inverse, left, left
## Application

3.Application in monitoring the growth status of crops

---
class: left, left
## Reflection (why interesting &amp; how useful)

* What I have learnt?

The OLI sensor is a significant upgrade over previous sensors carried by the Landsat series of satellites, returning remote sensing images that can be used to target urban, farm, forest and other types of areas.

However, it still has limitations. For instance, because its spatial resolution, it cannot be used to classify classes of land use detailed and monitor land use change in small areas (e.g. Variation of vegetation species distribution in wetland park) 

From this week lecture, I learnt differences between level-1 and level-2 data, and also what is image correlation and enhancement, and the principle of them.

--

* Future work

In the future, I will focus more on exploring other sensors which carried by  satellites launched recently and comparing the differences between them. It might be helpful for me to review the contents in the courses, and also be familiar with the characteristics of these sensors, so that more appropriate data can be selected easier for research according to the different characteristics of the data collected by different sensors.

 

---
class: left, left
##References
--

```r
#remotes::install_github("ropensci/RefManageR")
library(RefManageR)
library(knitcitations)
BibOptions(check.entries = FALSE,
           bib.style = "authoryear",
           cite.style = "authoryear",
           style = "markdown",
           hyperlink = TRUE,
           dashed = FALSE,
          no.print.fields=c("doi", "url", "urldate", "issn"))
myBib &lt;- ReadBib("./literature/RS_wk2/RS_wk2.bib", check = FALSE)
#citep(myBib,"lovelandLandsatBuildingStrong2012")
```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
